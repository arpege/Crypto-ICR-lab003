\documentclass[a4paper]{report}

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[font=bf,skip=\baselineskip]{caption}


\usepackage{minted}
\usepackage{listings}
\usepackage{hyperref}

\usepackage{lastpage}
\usepackage{fancyhdr}
\usepackage{setspace}

\lstset{
    literate={~} {$\sim$}{1}
}

\usepackage{titling}
\newcommand{\subtitle}[1]{
  \posttitle{
    \par\end{center}
    \begin{center}\large#1\end{center}
    \vskip0.5em}
}

\newmint{python}{
frame=lines,
framesep=2mm,
linenos,
breaklines=true,
}

\newmintedfile[ccode]{c}{
    breaklines=true,
    fontfamily=tt,
    linenos=true,
    numberblanklines=true,
    numbersep=12pt,
    numbersep=5pt,
    frame=leftline,
    framerule=0.4pt,
    framesep=2mm,
    funcnamehighlighting=true,
    tabsize=4,
    obeytabs=false,
    mathescape=false,
    samepage=false,
    showspaces=false,
    showtabs =false,
    texcl=false,
    mathescape=true,
}



% PAGE STYLE
\pagestyle{fancy}
\fancyhf{}

\lhead{Industrial Cryptography}
\rhead{Fault Attacks against RSA-CRT}
\cfoot{Page \thepage \hspace{1pt} sur \pageref{LastPage}}

\fancypagestyle{plain}{%
\fancyhf{} % vide l’en-tête et le pied~de~page.
\fancyhead[R]{Industrial Cryptography -- Fault Attacks against RSA-CRT}
\fancyfoot[C]{Page \thepage \hspace{1pt} sur \pageref{LastPage}} % numéro de la page en cours en gras
% et centré en pied~de~page.
\renewcommand{\headrulewidth}{0pt}
\renewcommand{\footrulewidth}{0pt}}



% TITLE PAGE
\title{ICR -- Practical Work \#3}
\subtitle{Fault Attacks against RSA-CRT}

\author{Gugger Joël \thanks{\ \href{mailto:joel.gugger@master.hes-so.ch}{joel.gugger@master.hes-so.ch}}}
\date{\today}

\pagenumbering{arabic}
\begin{document} 
\maketitle

\abstract{A way to accelerate the RSA signature procedure consists in exploiting the fact that one knows the two primes p and q, as it is a private-key operation, and to use the Chinese Remainder Theorem (CRT). 

The goal of this practical work consists in implementing a fast RSA signature procedure that exploits the CRT and to study the security of such an implementation at the light of fault attacks. This practical work can be implemented either in C, C++, Java or Python, with the big-numbers arithmetic library of your choice.}

\tableofcontents

 
\chapter{RSA-CRT}
This part is dedicated to the implementation of a RSA-CRT fast signing procedure. One can assume that 1024-bit RSA keys are used and that the digest formatting operation is performed elsewhere.

\section{Questions}
\subsection{How have you tested that your routines are properly working?}

\subsection{What is the gain in terms of speed that you obtain when using RSA-CRT with respect to a standard RSA signature generation procedure?}

\subsection{What are the values that one could pre-compute and store besides n and d, in order to speed up as much as possible the signature generation procedure?}


\section{Implementation}
\subsection{RSA key generation routine}
The implementation is based on the corrected series of exercises one of the course. Modification were made to the structure of the private key to store the necessary variables for the RSA -CRT implementation.

\ccode[firstline=32, lastline=40]{../src/rsa.c}

For using the Chinese remainder algorithm, we need to compute three additional variables :

\[
d_p = e^{-1} \ (\bmod{\ p - 1} )
\]
\[
d_q = e^{-1} \ (\bmod{\ q - 1} )
\]
\[
q_{inv} = q^{-1} \ ( \bmod{\ p} )
\]

To calculate these variables, the generation routine was modified. GMP library provides a built in method to make this calculs. 

\ccode[firstline=125, lastline=136]{../src/rsa.c}

\subsection{Standard RSA signature and verification routines}
The RSA signature scheme works like this:
\begin{enumerate}
    \item Creates a message digest of the information to be sent.
    \item Represents this digest as an integer $m$ between 1 and $n-1$.
    \item Uses her private key $(n, d)$ to compute the signature $s = m^d  \ (\bmod{\ n} )$.
    \item Sends this signature s to the recipient, B.
\end{enumerate}

To implement this feature , I add a generate\_textbookRSA\_standard\_signature method. The method takes the big number mpz\_t, the data to be signed and the private key. An implementation of SHA256 is used to create the digest\footnote{\ See \href{http://bradconte.com/sha256\_c}{http://bradconte.com/sha256\_c}.}.

\ccode[firstline=220, lastline=251]{../src/rsa.c}

Implementing the RSA signature verification scheme is similar to the signature generation routine, pretty much the same code. The protocol works like this:
\begin{enumerate}
    \item Uses sender A's public key $(n, e)$ to compute integer $v = s^e  \ (\bmod{\ n} )$.
    \item Extracts the message digest from this integer.
    \item Independently computes the message digest of the information that has been signed.
    \item If both message digests are identical, the signature is valid.
\end{enumerate}

The same SHA256 implementation is used. First we compute the data digest, and secondly we apply the formula:

\[
v = s^e  \ (\bmod{\ n} )
\]

Finally the two results are compared. If they are of the same value, then the signature is correct and is really from the expected private key. Otherwise, the data were changed or private key is not good.

\ccode[firstline=296, lastline=337]{../src/rsa.c}

\newpage
\subsection{Fast RSA signature procedure}
We can use the CRT to compute $m = c^d\ (\bmod{\ n})$ more efficiently. To do this, we need to precompute the following values given p, q with $p > q$

\[
d_p = e^{-1} \ (\bmod{\ p - 1} )
\]
\[
d_q = e^{-1} \ (\bmod{\ q - 1} )
\]
\[
q_{inv} = q^{-1} \ ( \bmod{\ p} )
\]

With these values, we can compute the message $m$ given $c$ with

\[
m1 = c^{d_p}\ (\bmod\ p)
\]
\[
m2 = c^{d_q}\ (\bmod\ q)
\]
\[
h = q_{inv} * (m1 - m2)\ (\bmod\ p)
\]
\[
m = m2 + h*q 
\]

\ccode[firstline=254, lastline=293]{../src/rsa.c}


\chapter{Boneh-DeMillo-Lipton Attack}
In 1997, Boneh, DeMillo and Lipton have demonstrated that if a fault is induced during one of the two partial signature computation steps, that erroneous signature can be exploited in order to factor the public modulus.

\section{Mathematical description}
\textbf{Task 2.} \textit{Describe in mathematical terms how the Boneh-DeMillo-Lipton fault attack against RSA-CRT is working.}

\section{Questions}
\subsection{In practice, how is it possible to induce faults in cryptographic implementations?}
\subsection{Is this attack working on a non-deterministic padding scheme?}

\section{Simulating Boneh-DeMillo-Lipton attack}
\textbf{Task 3.} \textit{Write a program simulating Boneh-DeMillo-Lipton attack that allows to factor $n = p*q$ in a very efficient way.}


\chapter{Implementing Shamir’s Trick}
Several countermeasures have been proposed to defend against Boneh-DeMillo-Lipton attack. In this part, we will study and implement the one that is known as \textit{Shamir’s trick}. This technique essentially works as follows: the partial signatures are computed modulo $rp$ and $rq$, where $r$ is a small (i.e., 32-bit) random integer, instead of working modulo $p$ and $q$, respectively.

\section{Mathematical description}
\textbf{Task 4.} \textit{Describe in mathematical terms how Shamir’s trick works.}

\section{Implementation}
\textbf{Task 5.} \textit{Implement an RSA-CRT routine protected against Boneh-DeMillo-Lipton attack thanks to Shamir’s trick.}


\newpage
\vspace*{6 cm}
\begin{center}
\textbf{Abstract} \\
\ \\
The sources of the project are available on GitHub at the following address: \\
\href{https://github.com/GuggerJoel/Crypto-ICR-lab003}{https://github.com/GuggerJoel/Crypto-ICR-lab003}
\end{center}





\end{document}