\documentclass[a4paper]{report}

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[font=bf,skip=\baselineskip]{caption}


\usepackage{minted}
\usepackage{listings}
\usepackage{hyperref}

\usepackage{lastpage}
\usepackage{fancyhdr}
\usepackage{setspace}

\lstset{
    literate={~} {$\sim$}{1}
}

\usepackage{titling}
\newcommand{\subtitle}[1]{
  \posttitle{
    \par\end{center}
    \begin{center}\large#1\end{center}
    \vskip0.5em}
}

\newmint{python}{
frame=lines,
framesep=2mm,
linenos,
breaklines=true,
}

\newmintedfile[ccode]{c}{
    breaklines=true,
    fontfamily=tt,
    linenos=true,
    numberblanklines=true,
    numbersep=12pt,
    numbersep=5pt,
    frame=leftline,
    framerule=0.4pt,
    framesep=2mm,
    funcnamehighlighting=true,
    tabsize=4,
    obeytabs=false,
    mathescape=false,
    samepage=false,
    showspaces=false,
    showtabs =false,
    texcl=false,
    mathescape=true,
}



% PAGE STYLE
\pagestyle{fancy}
\fancyhf{}

\lhead{Industrial Cryptography}
\rhead{Fault Attacks against RSA-CRT}
\cfoot{Page \thepage \hspace{1pt} sur \pageref{LastPage}}

\fancypagestyle{plain}{%
\fancyhf{} % vide l’en-tête et le pied~de~page.
\fancyhead[R]{Industrial Cryptography -- Fault Attacks against RSA-CRT}
\fancyfoot[C]{Page \thepage \hspace{1pt} sur \pageref{LastPage}} % numéro de la page en cours en gras
% et centré en pied~de~page.
\renewcommand{\headrulewidth}{0pt}
\renewcommand{\footrulewidth}{0pt}}



% TITLE PAGE
\title{ICR -- Practical Work \#3}
\subtitle{Fault Attacks against RSA-CRT}

\author{Gugger Joël \thanks{\ \href{mailto:joel.gugger@master.hes-so.ch}{joel.gugger@master.hes-so.ch}}}
\date{\today}

\pagenumbering{arabic}
\begin{document} 
\maketitle

\abstract{A way to accelerate the RSA signature procedure consists in exploiting the fact that one knows the two primes p and q, as it is a private-key operation, and to use the Chinese Remainder Theorem (CRT). 

The goal of this practical work consists in implementing a fast RSA signature procedure that exploits the CRT and to study the security of such an implementation at the light of fault attacks. This practical work can be implemented either in C, C++, Java or Python, with the big-numbers arithmetic library of your choice.}

\tableofcontents

 
\chapter{RSA-CRT}
This part is dedicated to the implementation of a RSA-CRT fast signing procedure. One can assume that 1024-bit RSA keys are used and that the digest formatting operation is performed elsewhere.

\section{Questions}
\subsection{How have you tested that your routines are properly working?}

\subsection{What is the gain in terms of speed that you obtain when using RSA-CRT with respect to a standard RSA signature generation procedure?}

\subsection{What are the values that one could pre-compute and store besides n and d, in order to speed up as much as possible the signature generation procedure?}


\section{Implementation}
\subsection{RSA key generation routine}
The implementation is based on the corrected series of exercises one of the course. Modification were made to the structure of the private key to store the necessary variables for the RSA -CRT implementation.

\ccode[firstline=32, lastline=40]{../src/rsa.c}

For using the Chinese remainder algorithm, we need to compute three additional variables :

\[
d_p = e^{-1} \ (\bmod{\ p - 1} )
\]
\[
d_q = e^{-1} \ (\bmod{\ q - 1} )
\]
\[
q_{inv} = q^{-1} \ ( \bmod{\ p} )
\]

To calculate these variables, the generation routine was modified. GMP library provides a built in method to make this calculs. 

\ccode[firstline=125, lastline=136]{../src/rsa.c}

\subsection{Standard RSA signature and verification routines}
The RSA signature scheme works like this:
\begin{enumerate}
    \item Creates a message digest of the information to be sent.
    \item Represents this digest as an integer $m$ between 1 and $n-1$.
    \item Uses her private key $(n, d)$ to compute the signature $s = m^d  \ (\bmod{\ n} )$.
    \item Sends this signature s to the recipient, B.
\end{enumerate}

To implement this feature , I add a generate\_textbookRSA\_standard\_signature method. The method takes the big number mpz\_t, the data to be signed and the private key. An implementation of SHA256 is used to create the digest\footnote{\ See \href{http://bradconte.com/sha256\_c}{http://bradconte.com/sha256\_c}.}.

\ccode[firstline=220, lastline=251]{../src/rsa.c}

Implementing the RSA signature verification scheme is similar to the signature generation routine, pretty much the same code. The protocol works like this:
\begin{enumerate}
    \item Uses sender A's public key $(n, e)$ to compute integer $v = s^e  \ (\bmod{\ n} )$.
    \item Extracts the message digest from this integer.
    \item Independently computes the message digest of the information that has been signed.
    \item If both message digests are identical, the signature is valid.
\end{enumerate}

The same SHA256 implementation is used. First we compute the data digest, and secondly we apply the formula:

\[
v = s^e  \ (\bmod{\ n} )
\]

Finally the two results are compared. If they are of the same value, then the signature is correct and is really from the expected private key. Otherwise, the data were changed or private key is not good.

\ccode[firstline=296, lastline=337]{../src/rsa.c}

\newpage
\subsection{Fast RSA signature procedure}
We can use the CRT to compute $m = c^d\ (\bmod{\ n})$ more efficiently. To do this, we need to precompute the following values given p, q with $p > q$

\[
d_p = e^{-1} \ (\bmod{\ p - 1} )
\]
\[
d_q = e^{-1} \ (\bmod{\ q - 1} )
\]
\[
q_{inv} = q^{-1} \ ( \bmod{\ p} )
\]

With these values, we can compute the message $m$ given $c$ with

\[
m1 = c^{d_p}\ (\bmod\ p)
\]
\[
m2 = c^{d_q}\ (\bmod\ q)
\]
\[
h = q_{inv} * (m1 - m2)\ (\bmod\ p)
\]
\[
m = m2 + h*q 
\]

The RSA -CRT implementation is similar in all respects to the standard implementation. Only the calculation portion varies. Again, the GMP library provided us with the necessary methods for calculations on large numbers.

\ccode[firstline=275, lastline=287]{../src/rsa.c}

For a given string of characters, both implementations provide the same signature. This signature is then verified by the function verify\_textbookRSA\\\_standard\_signature. If the signature is not valide, an error message is output.

\ccode[firstline=361, lastline=377]{../src/rsa.c}

This code displays the following results. Both generation routine output the same result, the verification pass the first time, and the second verification, which has failed, failed. The behavior is as expected.

\begin{minted}[
    linenos=true,
    breaklines=true,
    frame=leftline,
    framerule=0.4pt,
    framesep=2mm,
    tabsize=4,]{bash}
s : 768888fb6b65df66c8b0857cbc494728a8736c77d02bdc09\
461f48baba0219702737eb8ee4540caf6d2bf1d1b8fca7b1aae8\
1c3810f00712ef042417d4ebff335c05c6112c10ec9314b1a577d\
99084ff5974492161e9ba90f290dc592315980963323e41a89c7\
c18d9ad88a4e6bb1eb6e66b784e5b8a01d6eae657547d16849\
b751a9c5091326a3c2a3ed2f49caba7bc86e4e36c75ed44b4ed\
94320dc2b66c42531a6e0f25b8b0ef0d67d529adf6fdf05fe1d6ff\
0916f743da5b891903d893d66a4a34a5b5507b8e6bc7db34917\
b2c099bc30c0160377ac4b174ec5a696dc540f802b39b921805\
551da00bf861900e088199377c7d2c2cd4e827c879d9bb651

RSA-CRT signature:
s : 768888fb6b65df66c8b0857cbc494728a8736c77d02bdc094\
61f48baba0219702737eb8ee4540caf6d2bf1d1b8fca7b1aae81\
c3810f00712ef042417d4ebff335c05c6112c10ec9314b1a577d\
99084ff5974492161e9ba90f290dc592315980963323e41a89c\
7c18d9ad88a4e6bb1eb6e66b784e5b8a01d6eae657547d168\
49b751a9c5091326a3c2a3ed2f49caba7bc86e4e36c75ed44b\
4ed94320dc2b66c42531a6e0f25b8b0ef0d67d529adf6fdf05fe\
1d6ff0916f743da5b891903d893d66a4a34a5b5507b8e6bc7d\
b34917b2c099bc30c0160377ac4b174ec5a696dc540f802b39\
b921805551da00bf861900e088199377c7d2c2cd4e827c879\
d9bb651

v : b19318d0e9ba063a5fe94bc3cb9d9b5d79e06bfed220c86fb137cb40aef36140

m : b19318d0e9ba063a5fe94bc3cb9d9b5d79e06bfed220c86fb137cb40aef36140

v : b19318d0e9ba063a5fe94bc3cb9d9b5d79e06bfed220c86fb137cb40aef36140

m : 78f5975a5d705e9528dd0e8d41206534b7e8c269b139bb151d5c0ca0928247c3

Error: signature not valid
\end{minted}


\chapter{Boneh-DeMillo-Lipton Attack}
In 1997, Boneh, DeMillo and Lipton have demonstrated that if a fault is induced during one of the two partial signature computation steps, that erroneous signature can be exploited in order to factor the public modulus.

\section{Mathematical description}
\textbf{Task 2.} \textit{Describe in mathematical terms how the Boneh-DeMillo-Lipton fault attack against RSA-CRT is working.}

\section{Questions}
\subsection{In practice, how is it possible to induce faults in cryptographic implementations?}
\subsection{Is this attack working on a non-deterministic padding scheme?}

\section{Simulating Boneh-DeMillo-Lipton attack}
\textbf{Task 3.} \textit{Write a program simulating Boneh-DeMillo-Lipton attack that allows to factor $n = p*q$ in a very efficient way.}


\chapter{Implementing Shamir’s Trick}
Several countermeasures have been proposed to defend against Boneh-DeMillo-Lipton attack. In this part, we will study and implement the one that is known as \textit{Shamir’s trick}. This technique essentially works as follows: the partial signatures are computed modulo $rp$ and $rq$, where $r$ is a small (i.e., 32-bit) random integer, instead of working modulo $p$ and $q$, respectively.

\section{Mathematical description}
\textbf{Task 4.} \textit{Describe in mathematical terms how Shamir’s trick works.}

\section{Implementation}
\textbf{Task 5.} \textit{Implement an RSA-CRT routine protected against Boneh-DeMillo-Lipton attack thanks to Shamir’s trick.}


\newpage
\vspace*{6 cm}
\begin{center}
\textbf{Abstract} \\
\ \\
The sources of the project are available on GitHub at the following address: \\
\href{https://github.com/GuggerJoel/Crypto-ICR-lab003}{https://github.com/GuggerJoel/Crypto-ICR-lab003}
\end{center}





\end{document}